---
layout: default
title: Transaction Propagation
grand_parent: Springs
parent: Spring Frameworks
nav_order: 4
---

propagation 관련 해서 내용이 많아서 별도 파일로 정리함.



# propagation (전파옵션)
트랜잭션 동작 도중 다른 트랜잭션을 호출(실행)하는 상황이에 선택할 수 있는 옵션이다.

@Transactional의 propagation 속성을 통해 피호출 트랜잭션의 입장에서는 호출한 쪽의 트랜잭션을 그대로 사용할 수도 있고, 새롭게 트랜잭션을 생성할 수도 있다.



### REQUIRED
 - 디폴트 속성
 - 부모 트랜잭션 내에서 실행하며 부모 트랜잭션이 없을 경우 새로운 트랜잭션을 생성한다.


### REQUIRES_NEW
 - 부모 트랜잭션을 무시하고 무조건 새로운 트랜잭션이 생성
 - 이미 진행 중인 트랜잭션이 있으면 트랜잭션을 잠시 보류시킨다.
 - NESTED와 다른점은 NESTED의 경우 부모 트랜잭션에 의해서 자식 트랜잭션이 영향을 받는다는 점이다.


### MANDATORY
 - REQUIRED와 비슷하게 이미 시작된 부모 트랜잭션이 있으면 참여한다. 
 - 반면에 트랜잭션이 시작된 것이 없으면 새로 시작하는 대신 예외를 발생시킨다. 
 - 혼자서는 독립적으로 트랜잭션을 진행하면 안 되는 경우에 사용한다.

### SUPPORTS
 - 메소드가 트랜잭션을 필요로 하지는 않지만, 진행 중인 트랜잭션이 존재하면 트랜잭션을 사용한다는 것을 의미한다.
 - 진행 중인 트랜잭션이 존재하지 않더라도 메소드는 정상적으로 동작한다.


### NESTED
 - 이미 진행중인 트랜잭션이 있으면 중첩 트랜잭션을 시작한다. 중첩 트랜잭션은 트랜잭션 안에 다시 트랜잭션을 만드는 것이다.
 - 하지만 독립적인 트랜잭션을 만드는 REQUIRES_NEW와는 다르다.
 - 부모 트랜잭션에 예외가 발생하면 자식 트랜잭션도 rollback한다.
 - 현재 트랜잭션이 있으면 중첩 트랜잭션 내에서 실행하고, 그렇지 않으면 REQUIRED 처럼 동작합니다.

아래는 반드시 기억해둬야 하는 내용일 거 같다.
 - 중첩된 트랜잭션은 먼저 시작된 부모 트랜잭션의 커밋과 롤백에는 영향을 받지만 자신의 커밋과 롤백은 부모 트랝개션에게 영향을 주지 않는다.
 - 자식 트랜잭션에 예외가 발생하더라도 부모 트랜잭션은 rollback하지 않는다. 이때 롤백은 부모 트랜잭션에서 자식 트랜잭션을 호출하는 지점까지만 롤백된다. 이후 부모 트랜잭션에서 문제가 없으면 부모 트랜잭션은 끝까지 commit 된다.
   => (이 동작은 JDBC버전에 영향을 받기 때문에, 실 서비스전에 테스트가 필요하다)


### NOT_SUPPORTED
 - 트랜잭션을 사용하지 않게 한다.
 - 이미 진행 중인 트랜잭션이 있으면 보류시킨다.


### NEVER
 - 트랜잭션을 사용하지 않도록 강제한다.
 - 이미 진행 중인 트랜잭션도 존재하면 안된다 있다면 예외를 발생시킨다.



1. 어떤 작업을 진행하는 중 로그는 꼭 DB에 저장해야 할 때
   이 로그를 저장하는 작업이 실패한다고 메인 작업의 트랜잭션까지는 롤백되버린다면 특히 쇼핑몰에서 고객 주문작업 등의 경우 매출 하락까지도 발생할 수 있는 중요한 문제이다.
   반대로 로그를 남긴 후 메인 작업에서 예외가 발생한다면 이때는 저장한 로그도 롤백 되어야 하는게 맞다.
   이럴 때 로그 작업을 메인 트랜잭션에서 분리해서 중첩 트랜잭션으로 만들어 두면 유용하게 사용할 수 있다. 이렇게 때문에 더욱 더 Business 로직을 잘 짜줘야 할 것이다.
   중첩 트랜잭션은 JDBC 3.0 스펙의 저장포인트(savepoint) (클릭시 자세한 내용링크) 를 지원하는 드라이버와 DataSourceTransactionManager 를 이용할 경우에 적용 가능하다.


ex)
```
public void something (int a) {
    …
}
```


# Propagation 관련 동작 

 * https://devlog-wjdrbs96.tistory.com/424
   + 예외 발생시의 영향도에 대한 블로그


### REQUIRED

자식/부모에서 rollback이 발생된다면 자식과 부모 모두 rollback 한다



### REQUIRES_NEW

##### 자식에서 예외 발생 부모에서 예외 처리 안함

REQUIRES_NEW는 자식 트랜잭션에서 발생한 것이 부모 트랜잭션 까지 전파되지 않는다고하는데, 부모/자식 모두 rollback 된다.

댓글로 첨언해주신 것을 기반으로 좀 더 설명을 보강하자면 "트랜잭션이 전파"되는 것과 "예외가 전파" 되는 것은 다르다.

자식 쪽에 예외가 발생할 경우 자식 쪽은 트랜잭션이 롤백이 되는 것이 맞습니다. 

그런데 이 때 자식 쪽에서 발생한 예외가 부모 쪽으로 전파되기 때문에 부모 쪽에서도 예외가 발생하여 롤백이 일어난 것으로 이해해야 맞을 것 같습니다.


##### 자식에서 발생한 예외 부모에서 예외 처리

자식에서 발생한 예외를 부모에서 try-catch로 묶으면, 자식 트랜잭션을 호출하기 전까지의 쿼리만 커밋된 것을 확인할 수 있습니다. 

예외 처리를 해주어야 부모 트랜잭션도 자식 트랜잭션에 영향을 받지 않고 커밋을 하는 것 같습니다.

##### 부모에서 예외 발생

부모에서 예외가 발생해도, 자식 트랜잭션은 반영된다.

REQUIRES_NEW는 부모 트랜잭션에서 예외가 발생해도 자식 트랜잭션에서는 꼭 커밋되어야 하는 상황에서 사용하면 좋을 것 같습니다.



### MANDATORY

MANDATORY는 부모 트랜잭션이 존재하면 무조건 부모 트랜잭션에 합류시키고, 부모 트랜잭션에 트랜잭션이 시작된 것이 없다면 예외를 발생시킵니다. 

즉, 혼자서는 독립적으로 트랜잭션을 진행하면 안되는 경우에 사용합니다. 자식에서 예외가 발생하기 전까지만 저장됨.



### NESTED

##### 부모에서 예외 발생

NESTED 속성에서는 부모 트랜잭션에서 에러가 발생하면 자식 트랜잭션은 어떻게 되는지 알아보겠습니다. 

위의 코드를 실행하면 자식 트랜잭션도 커밋이 되지 않습니다. 

이유는 부모 트랜잭션이 존재하면 자식 트랜잭션도 부모 트랜잭션에 합류하기 때문입니다.


##### 자식에서 예외 발생 보무에서 예외처리 안함

자식에서 예외가 발생하여도 마찬가지로 어떤 값도 User에 저장되지 않습니다.

=> 예외를 발생했을 때 에러 로그를 보면 JpaDialect does not support savepoints - check your JPA provider's capabilities가 발생합니다. NESTED는 JDBC 3.0 드라이버를 사용할 때에만 적용된다 라는 특징이 있습니다.


##### 자식에서 예외 발생한 예외 부모에서 예외 처리

자식 트랜잭션을 호출하기 전 부모 트랜잭션에서 호출한 INSERT 쿼리까지 커밋됨.


##### 부모 트랜잭션이 없을 경우

NESTED 속성은 부모 트랜잭션이 존재하지 않는다면 새로운 트랜잭션을 생성해서 처리한다.



### NEVER

NEVER는 메소드가 트랜잭션을 필요로 하지 않는다. 만약 진행 중인 트랜잭션이 존재하면 익셉션이 발생


